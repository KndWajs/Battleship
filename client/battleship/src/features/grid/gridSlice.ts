import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit';
import {RootState} from '../../app/store';
import {LocationStatus} from "../../shared/enums/LocationStatus";
import {shotCall, startNewGame} from "./gridAPI";
import {GameStatus} from "../../shared/enums/GameStatus";
import {ShotType} from "../../shared/enums/ShotType";
import Response from "../../shared/response";

export interface GridState {
    status: GameStatus,
    grid: LocationStatus[][],
    location: string
}

const emptyGrid: LocationStatus[][] = Array(10).fill(Array(10).fill(LocationStatus.EMPTY)) as LocationStatus[][];

const initialState: GridState = {
    status: GameStatus.BEFORE,
    grid: emptyGrid,
    location: "D5"
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// @ts-ignore
export const shot = createAsyncThunk(
    'grid/shot',
    async (coordinates: string, {rejectWithValue}) => {
        try {
            let newVar = await shotCall(coordinates);
            return newVar;
        } catch (err) {
            // @ts-ignore
            return rejectWithValue(err.response.data[0]);
        }
    }
);

export const startNewGameAction = createAsyncThunk(
    'grid/start-new-game',
    async () => {
        let newVar = await startNewGame();
        return newVar;
    }
);

export const gridSlice = createSlice({
    name: 'grid',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        setLocation: (state, action: PayloadAction<string>) => {
            state.location = action.payload;
        },
        // decrement: (state) => {
        //     state.value -= 1;
        // },
        // // Use the PayloadAction type to declare the contents of `action.payload`
        // incrementByAmount: (state, action: PayloadAction<number>) => {
        //     state.value += action.payload;
        // },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(shot.pending, (state) => {
                state.status = GameStatus.LOADING;
            })
            .addCase(shot.fulfilled, (state, action) => {
                let newStatus: LocationStatus;
                let payload = action.payload.data as Response;
                switch (payload.shot) {
                    case ShotType.HIT: {
                        newStatus = LocationStatus.WRECK;
                        break;
                    }
                    case ShotType.MISS: {
                        newStatus = LocationStatus.MISS;
                        break;
                    }
                    case ShotType.SINK: {
                        newStatus = LocationStatus.WRECK;
                        window.alert("Ship was completely destroyed!");
                        break;
                    }
                    case ShotType.END: {
                        newStatus = LocationStatus.WRECK;
                        state.status = GameStatus.BEFORE;
                        window.alert("You WIN!");
                        break;
                    }
                    default: {
                        newStatus = state.grid[payload.row][payload.column];
                        window.alert("Something went wrong...");
                    }
                }
                state.grid[payload.row][payload.column] = newStatus;
            })
            .addCase(shot.rejected, (state, action) => {
                // @ts-ignore
                window.alert(action.payload);
                state.status = GameStatus.FAILED;
            })
            .addCase(startNewGameAction.pending, (state) => {
                state.status = GameStatus.LOADING;
            })
            .addCase(startNewGameAction.fulfilled, (state, action) => {
                state.grid = emptyGrid
                console.log(action)
                state.status = GameStatus.ONGOING;
            })
            .addCase(startNewGameAction.rejected, (state, action) => {
                // @ts-ignore
                window.alert(action.payload);
                state.status = GameStatus.FAILED;
            });
    },
});

export const {setLocation} = gridSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.grid.value)`
export const selectGrid = (state: RootState) => state.grid.grid;
export const selectLocation = (state: RootState) => state.grid.location;
export const selectStatus = (state: RootState) => state.grid.status;

export default gridSlice.reducer;
